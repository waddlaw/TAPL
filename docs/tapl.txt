-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package tapl
@version 0.0.0

module Language.B.Types
data Term
TmTrue :: Term
TmFalse :: Term
TmIf :: Term -> Term -> Term -> Term
data Rule
E_IFTRUE :: Rule
E_IFFALSE :: Rule
E_IF :: Rule
newtype EvalRelation
EvalRelation :: (Term, Term) -> EvalRelation
[unwrap] :: EvalRelation -> (Term, Term)
type Premise = EvalRelation
type Conclusion = EvalRelation
instance GHC.Show.Show Language.B.Types.EvalRelation
instance GHC.Classes.Eq Language.B.Types.EvalRelation
instance GHC.Show.Show Language.B.Types.Rule
instance GHC.Enum.Bounded Language.B.Types.Rule
instance GHC.Enum.Enum Language.B.Types.Rule
instance GHC.Show.Show Language.B.Types.Term
instance GHC.Classes.Eq Language.B.Types.Term
instance Data.Text.Prettyprint.Doc.Internal.Pretty Language.B.Types.EvalRelation
instance Data.Text.Prettyprint.Doc.Internal.Pretty Language.B.Types.Rule
instance Data.Text.Prettyprint.Doc.Internal.Pretty Language.B.Types.Term

module Language.B.Example
example :: EvalRelation

module Language.NB.Types
data Term
TmTrue :: Term
TmFalse :: Term
TmIf :: Term -> Term -> Term -> Term
TmZero :: Term
TmSucc :: Term -> Term
TmPred :: Term -> Term
TmIsZero :: Term -> Term
data TmError
NoRuleApplies :: TmError
instance GHC.Show.Show Language.NB.Types.TmError
instance GHC.Classes.Eq Language.NB.Types.TmError
instance GHC.Show.Show Language.NB.Types.Term
instance GHC.Classes.Eq Language.NB.Types.Term

module Language.NB
isNumericalVal :: Term -> Bool
isVal :: Term -> Bool
eval :: Term -> Term

module Language.Utils
trim :: String -> String

module Language.Utils.Parser
runParserString :: Parser a -> String -> Either String a

module Language.B.Parser
bparser :: String -> Either String EvalRelation
stepCmdParser :: String -> Either String Int

module Language.B
deduce :: Rule -> Conclusion -> Maybe Premise
step :: Rule -> Maybe Premise -> Maybe Premise

-- | 項の評価関係
--   
--   評価関係 t -&gt; t' は「tが1ステップでt'に評価される」と読む
reduction :: Maybe Premise -> Term -> Term

module Term.Types

-- | <ul>
--   <li><i>定義 3.2.1 帰納的な項の定義</i></li>
--   </ul>
--   
--   <ul>
--   <li>項の集合とは3つの条件を満たす最小の集合Tである</li>
--   <li>「最小の」という言葉は T が3つの条件によって要求される要素以外を持たないという意味。</li>
--   <li>True, False は Bool の値とかぶるので先頭に T をつけることにする</li>
--   <li>全てが Term の値であることを明示的にするため、GADT で書いたが、普通に ADT で書いても良い</li>
--   </ul>
data Term
[TTrue] :: Term
[TFalse] :: Term
[Zero] :: Term
[Succ] :: Term -> Term
[Pred] :: Term -> Term
[IsZero] :: Term -> Term
[If] :: Term -> Term -> Term -> Term
instance GHC.Generics.Generic Term.Types.Term
instance GHC.Show.Show Term.Types.Term
instance GHC.Classes.Ord Term.Types.Term
instance GHC.Classes.Eq Term.Types.Term
instance Data.Hashable.Class.Hashable Term.Types.Term
instance Test.QuickCheck.Arbitrary.Arbitrary Term.Types.Term

module Term.Set

-- | <ul>
--   <li><i>定義 3.2.3 具体的な項の定義</i> 各自然数 i について、集合 Si を以下のように定義する。</li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; s 0
--   fromList []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; s 1
--   fromList [TTrue,TFalse,Zero]
--   </pre>
s :: Int -> T

-- | <ul>
--   <li><i>定義 3.3.1 項tに現れる定数の集合を Consts(t) と書き、次のように定義する</i></li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; consts TTrue
--   fromList [TTrue]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; consts (Succ (Succ (Succ Zero)))
--   fromList [Zero]
--   </pre>
consts :: Term -> T

-- | <ul>
--   <li><i>定義 3.3.2 項tのサイズを size(t) と書き、次のように定義する</i></li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; size Zero
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; size (Succ (Succ (Succ Zero)))
--   4
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; size (If Zero (Succ (Succ Zero)) (Succ Zero))
--   7
--   </pre>
size :: Term -> Int

-- | <ul>
--   <li><i>項tの深さを depth(t) と書き、次のように定義する</i></li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; depth Zero
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; depth (Succ (Succ (Succ Zero)))
--   4
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; depth (If Zero (Succ (Succ Zero)) (Succ Zero))
--   4
--   </pre>
depth :: Term -> Int

-- | 与えられた Term が含まれる、最小の集合 T を作る
--   
--   <pre>
--   &gt;&gt;&gt; minT Zero
--   fromList [TTrue,TFalse,Zero]
--   </pre>
minT :: Term -> T

module Term.HashSet

-- | <ul>
--   <li><i>定義 3.2.3 具体的な項の定義</i> 各自然数 i について、集合 Si を以下のように定義する。</li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; s 0
--   fromList []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; s 1
--   fromList [TTrue,TFalse,Zero]
--   </pre>
s :: Int -> T

-- | <ul>
--   <li><i>定義 3.3.1 項tに現れる定数の集合を Consts(t) と書き、次のように定義する</i></li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; consts TTrue
--   fromList [TTrue]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; consts (Succ (Succ (Succ Zero)))
--   fromList [Zero]
--   </pre>
consts :: Term -> T

-- | <ul>
--   <li><i>定義 3.3.2 項tのサイズを size(t) と書き、次のように定義する</i></li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; size Zero
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; size (Succ (Succ (Succ Zero)))
--   4
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; size (If Zero (Succ (Succ Zero)) (Succ Zero))
--   7
--   </pre>
size :: Term -> Int

-- | <ul>
--   <li><i>項tの深さを depth(t) と書き、次のように定義する</i></li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; depth Zero
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; depth (Succ (Succ (Succ Zero)))
--   4
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; depth (If Zero (Succ (Succ Zero)) (Succ Zero))
--   4
--   </pre>
depth :: Term -> Int

-- | 与えられた Term が含まれる、最小の集合 T を作る
--   
--   <pre>
--   &gt;&gt;&gt; minT Zero
--   fromList [TTrue,TFalse,Zero]
--   </pre>
minT :: Term -> T
