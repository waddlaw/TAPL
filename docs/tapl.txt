-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package tapl
@version 0.0.0

module Language.B.Types
data Term
TmTrue :: Term
TmFalse :: Term
TmIf :: Term -> Term -> Term -> Term
data Rule
E_IFTRUE :: Rule
E_IFFALSE :: Rule
E_IF :: Rule
newtype EvalRelation
EvalRelation :: (Term, Term) -> EvalRelation
[unwrap] :: EvalRelation -> (Term, Term)
type Premise = EvalRelation
type Conclusion = EvalRelation
instance GHC.Show.Show Language.B.Types.EvalRelation
instance GHC.Classes.Eq Language.B.Types.EvalRelation
instance GHC.Show.Show Language.B.Types.Rule
instance GHC.Enum.Bounded Language.B.Types.Rule
instance GHC.Enum.Enum Language.B.Types.Rule
instance GHC.Show.Show Language.B.Types.Term
instance GHC.Classes.Eq Language.B.Types.Term
instance Data.Text.Prettyprint.Doc.Internal.Pretty Language.B.Types.EvalRelation
instance Data.Text.Prettyprint.Doc.Internal.Pretty Language.B.Types.Rule
instance Data.Text.Prettyprint.Doc.Internal.Pretty Language.B.Types.Term

module Language.B.Example
example :: EvalRelation

module Language.NB.Types
data Term
TmTrue :: Term
TmFalse :: Term
TmIf :: Term -> Term -> Term -> Term
TmZero :: Term
TmSucc :: Term -> Term
TmPred :: Term -> Term
TmIsZero :: Term -> Term
data TmError
NoRuleApplies :: TmError
instance GHC.Show.Show Language.NB.Types.TmError
instance GHC.Classes.Eq Language.NB.Types.TmError
instance GHC.Show.Show Language.NB.Types.Term
instance GHC.Classes.Eq Language.NB.Types.Term
instance Data.Text.Prettyprint.Doc.Internal.Pretty Language.NB.Types.Term

module Language.UntypedLambda.Types
data Term a
TmVar :: a -> Term a
TmLam :: VarName -> (Term a) -> Term a
TmApp :: (Term a) -> (Term a) -> Term a
data Strategy

-- | 完全ベータ簡約
FullBetaReduction :: Strategy

-- | 正規順序戦略
NormalOrder :: Strategy

-- | 名前呼び戦略
CallByName :: Strategy

-- | 値呼び戦略
CallByValue :: Strategy
type UntypedLambda = Term Text
(@@) :: UntypedLambda -> UntypedLambda -> UntypedLambda
λ :: Text -> UntypedLambda -> UntypedLambda

-- | 教科書とは逆で ["x", "y", "z"] は [0, 1, 2] と左からインデックスを付ける
type Context = [VarName]
type VarName = Text
data NamelessTerm
NlTmVar :: Int -> NamelessTerm
NlTmLam :: NamelessTerm -> NamelessTerm
NlTmApp :: NamelessTerm -> NamelessTerm -> NamelessTerm
getNlTermVar :: NamelessTerm -> Int
instance GHC.Enum.Bounded Language.UntypedLambda.Types.Strategy
instance GHC.Enum.Enum Language.UntypedLambda.Types.Strategy
instance GHC.Read.Read Language.UntypedLambda.Types.Strategy
instance GHC.Show.Show Language.UntypedLambda.Types.Strategy
instance GHC.Show.Show a => GHC.Show.Show (Language.UntypedLambda.Types.Term a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.UntypedLambda.Types.Term a)
instance GHC.Show.Show Language.UntypedLambda.Types.NamelessTerm
instance GHC.Classes.Eq Language.UntypedLambda.Types.NamelessTerm
instance Data.Text.Prettyprint.Doc.Internal.Pretty Language.UntypedLambda.Types.UntypedLambda
instance Data.String.IsString Language.UntypedLambda.Types.UntypedLambda
instance Data.String.IsString Language.UntypedLambda.Types.NamelessTerm

module Language.UntypedLambda.Lib.Bool

-- | λt. λf. t
tru :: UntypedLambda

-- | λt. λf. f
fls :: UntypedLambda

-- | λl. λm. λn. l m n
test :: UntypedLambda

-- | λb. λc. b c fls
and :: UntypedLambda

-- | λb. λc. b tru c
or :: UntypedLambda

-- | λb. b fls tru
not :: UntypedLambda
mkTest :: UntypedLambda -> UntypedLambda -> UntypedLambda -> UntypedLambda
mkAnd :: UntypedLambda -> UntypedLambda -> UntypedLambda
mkOr :: UntypedLambda -> UntypedLambda -> UntypedLambda
mkNot :: UntypedLambda -> UntypedLambda

module Language.UntypedLambda.Lib.Pair

-- | λf. λs. λb. b f s
pair :: UntypedLambda

-- | λp. p tru
fst :: UntypedLambda

-- | λp. p fls
snd :: UntypedLambda

-- | λf. λs. pair f s
mkPair :: UntypedLambda -> UntypedLambda -> UntypedLambda

module Language.UntypedLambda.Lib.Base

-- | λx. x
id :: UntypedLambda

-- | λf. (λx. f (λy. x x y)) (λx. f (λy. x x y))
fix :: UntypedLambda
mkFix :: Text -> UntypedLambda -> UntypedLambda -> UntypedLambda -> UntypedLambda

module Language.UntypedLambda.Lib.Church

-- | c0 = λs. λz. z
--   
--   c1 = λs. λz. s z
--   
--   c2 = λs. λz. s (s z)
--   
--   c3 = λs. λz. s (s (s z))
c :: Int -> UntypedLambda

-- | λn. λs. λz. s (n s z)
scc :: UntypedLambda

-- | λm. λn. λs. λz. m s (n s z)
plus :: UntypedLambda

-- | λm. λn. m (plus n) c0
times :: UntypedLambda

-- | λm. m (λx. fls) tru
iszro :: UntypedLambda

-- | λm. fst (m ss zz)
prd :: UntypedLambda

-- | λn. λs. λz. n s (s z)
scc2 :: UntypedLambda

-- | λm. λn. λs. λz. m (n s) z
times2 :: UntypedLambda

-- | λm. λn. λs. m (n s)
times3 :: UntypedLambda

-- | λn. λm. m (times n) c1
--   
--   n^m
power1 :: UntypedLambda

-- | λn. λm. m n
--   
--   m^n
power2 :: UntypedLambda

-- | λm. λn. n prd m
subtract1 :: UntypedLambda

-- | λm. λn. and (iszro (m prd n)) (iszro (n prd m))
equal :: UntypedLambda

-- | match = iszro n base = λx. c1 rec = λx. times n (f (prd n))
factorial :: UntypedLambda
isone :: UntypedLambda
mkPlus :: UntypedLambda -> UntypedLambda -> UntypedLambda
mkTimes :: UntypedLambda -> UntypedLambda -> UntypedLambda
mkSubtract :: UntypedLambda -> UntypedLambda -> UntypedLambda
mkEqual :: UntypedLambda -> UntypedLambda -> UntypedLambda

module Language.UntypedLambda.Lib.NB

-- | Church ブール値をプリミティブなブール値に変換 λb. b true false
realbool :: UntypedLambda

-- | プリミティブなブール値を Church ブール値に変換 λb. test b tru fls TODO: fake
churchbool :: UntypedLambda

-- | プリミティブなブール値を返す equal λm. λn. equal m n true false
realeq :: UntypedLambda

-- | Church 数からプリミティブな数への変換 λm. m (λx. succ x) 0
realnat :: UntypedLambda

-- | プリミティブな自然数を、対応する Church 数に変換する関数 match = iszro m base = λx rec = scc n
--   (f (prd m)) | TODO: fake
churchnat :: UntypedLambda

module Language.UntypedLambda.Lib.List

-- | λc. λn. n
nil :: UntypedLambda

-- | λh. λt. λc. λn. c h (t c n)
cons :: UntypedLambda

-- | λl. l (λh. λt. fls) tru
isnil :: UntypedLambda

-- | λl. l (λh. λt. h) l
head :: UntypedLambda

-- | λl. fst (l cc nn)
tail :: UntypedLambda

-- | match = isnil l base = c0 rec = plus (head l) (f (tail l))
sumlist :: UntypedLambda

-- | λl. l plus c0
sumlist' :: UntypedLambda

module Language.UntypedLambda.Prelude
prelude :: Map Text UntypedLambda

module Language.UntypedLambda.Lib.Int

-- | int = λb. λs. λz. z | λb. λs. λz. pair b (s z) 0 = λs. λz. z -1 = λs.
--   λz. pair fls (s z) +1 = λs. λz. pair tru (s z)
int :: Int -> UntypedLambda

-- | if isZero i then (True, 1) else if isNegative i then (fst i, prd (snd
--   i)) else (fst i, scc (snd i))
--   
--   λi. test (isZeroI i) (pair tru c1) (test (isPositiveI i) (pair (fst i)
--   (scc (snd i))) (pair (fst i) (prd (snd i))))
succI :: UntypedLambda

-- | match = iszro (fst p) base = snd p rec = succI (f (mkPair (prd (fst
--   p)) (snd p))
succNI :: UntypedLambda
plusI :: UntypedLambda

-- | λi. iszro (snd i)
isZeroI :: UntypedLambda

-- | λi. isone (snd i)
isAbsOneI :: UntypedLambda

module Language.Utils
trim :: String -> String
render :: Pretty a => a -> String
renderPrelude :: Pretty a => Map Text a -> String

module Language.Utils.Parser
runParserString :: Parser a -> String -> Either String a

module Language.UntypedLambda.Parser
runUlParser :: String -> Either String UntypedLambda

module Language.UntypedLambda

-- | 与えられた項が閉じているかどうか判定する述語
--   
--   項が閉じている = 自由変数が無い
--   
--   閉じた項はコンビネータとも呼ばれる。
isClosed :: UntypedLambda -> Bool

-- | 正規順序戦略
reduceNormalOrder :: UntypedLambda -> UntypedLambda

-- | 名前呼び戦略
reduceCallByName :: UntypedLambda -> UntypedLambda

-- | 値呼び戦略
reduceCallByValue :: UntypedLambda -> UntypedLambda

-- | 指定された評価戦略で項を正規系に評価する
eval :: Strategy -> UntypedLambda -> UntypedLambda

-- | 簡約ステップ列を返す
evalWithTrace :: Strategy -> [UntypedLambda] -> UntypedLambda -> [UntypedLambda]

-- | 1ステップのみ、指定された評価戦略で評価する
evalOneStep :: Strategy -> UntypedLambda -> UntypedLambda

-- | デバッグ用
trace :: Strategy -> UntypedLambda -> IO ()

-- | 簡約ステップ数を返す
steps :: UntypedLambda -> Int

-- | β-reduction
--   
--   定義5.3.5 (P.54)
subst :: Text -> UntypedLambda -> UntypedLambda -> UntypedLambda

-- | 項のサイズを計算する
--   
--   演習5.3.3 (P.52)
size :: UntypedLambda -> Int

-- | 演習6.1.5 (P.59)
--   
--   仮定: FV(t) ⊆ dom(Γ）)
removenames :: Context -> UntypedLambda -> NamelessTerm

-- | 演習6.1.5 (P.59)
--   
--   仮定1: Γに含まれる名前は互いに異なる 仮定2: 変数名の集合Vは順序付けられている
restorenames :: Context -> NamelessTerm -> UntypedLambda

-- | 定義6.2.1 (P.60)
--   
--   c: 打ち切り値
--   
--   d: シフト数
shift :: Int -> Int -> NamelessTerm -> NamelessTerm

-- | 定義6.2.4 (P.60)
namelessSubst :: Int -> NamelessTerm -> NamelessTerm -> NamelessTerm

-- | 名前無し項のβ簡約 (値呼び)
reduceNameless :: NamelessTerm -> NamelessTerm

module Language.UntypedLambda.Examples

-- | s t u
example1 :: UntypedLambda

-- | λx. (λy. ((x y) x))
example2 :: UntypedLambda

-- | (λx.x) ((λx.x) (λz. (λx.x) z))
example3 :: UntypedLambda

-- | (λx.x) x
example4 :: UntypedLambda

-- | λz. λx. λy. x (y z)
example5 :: UntypedLambda

-- | (λx. x (λx. x)) (u r)
example6 :: UntypedLambda

-- | test tru tru fls
example7 :: UntypedLambda

-- | and tru tru
example8 :: UntypedLambda

-- | and tru fls
example9 :: UntypedLambda

-- | fst (pair v w)
example10 :: UntypedLambda

-- | <ul>
--   <li><i>x</i></li>
--   </ul>
example11 :: UntypedLambda

module Language.NB.Parser
runNbParser :: String -> Either String Term

module Language.NB
isNumericalVal :: Term -> Bool
isVal :: Term -> Bool
eval :: Term -> Term

module Language.B.Parser
bparser :: String -> Either String EvalRelation
stepCmdParser :: String -> Either String Int

module Language.B
deduce :: Rule -> Conclusion -> Maybe Premise
step :: Rule -> Maybe Premise -> Maybe Premise

-- | 項の評価関係
--   
--   評価関係 t -&gt; t' は「tが1ステップでt'に評価される」と読む
reduction :: Maybe Premise -> Term -> Term

module Language.Utils.Pretty
prettyText :: Pretty a => a -> Text

module Term.Types

-- | <ul>
--   <li><i>定義 3.2.1 帰納的な項の定義</i></li>
--   </ul>
--   
--   <ul>
--   <li>項の集合とは3つの条件を満たす最小の集合Tである</li>
--   <li>「最小の」という言葉は T が3つの条件によって要求される要素以外を持たないという意味。</li>
--   <li>True, False は Bool の値とかぶるので先頭に T をつけることにする</li>
--   <li>全てが Term の値であることを明示的にするため、GADT で書いたが、普通に ADT で書いても良い</li>
--   </ul>
data Term
[TTrue] :: Term
[TFalse] :: Term
[Zero] :: Term
[Succ] :: Term -> Term
[Pred] :: Term -> Term
[IsZero] :: Term -> Term
[If] :: Term -> Term -> Term -> Term
instance GHC.Generics.Generic Term.Types.Term
instance GHC.Show.Show Term.Types.Term
instance GHC.Classes.Ord Term.Types.Term
instance GHC.Classes.Eq Term.Types.Term
instance Data.Hashable.Class.Hashable Term.Types.Term
instance Test.QuickCheck.Arbitrary.Arbitrary Term.Types.Term

module Term.Set

-- | <ul>
--   <li><i>定義 3.2.3 具体的な項の定義</i> 各自然数 i について、集合 Si を以下のように定義する。</li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; s 0
--   fromList []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; s 1
--   fromList [TTrue,TFalse,Zero]
--   </pre>
s :: Int -> T

-- | <ul>
--   <li><i>定義 3.3.1 項tに現れる定数の集合を Consts(t) と書き、次のように定義する</i></li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; consts TTrue
--   fromList [TTrue]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; consts (Succ (Succ (Succ Zero)))
--   fromList [Zero]
--   </pre>
consts :: Term -> T

-- | <ul>
--   <li><i>定義 3.3.2 項tのサイズを size(t) と書き、次のように定義する</i></li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; size Zero
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; size (Succ (Succ (Succ Zero)))
--   4
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; size (If Zero (Succ (Succ Zero)) (Succ Zero))
--   7
--   </pre>
size :: Term -> Int

-- | <ul>
--   <li><i>項tの深さを depth(t) と書き、次のように定義する</i></li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; depth Zero
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; depth (Succ (Succ (Succ Zero)))
--   4
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; depth (If Zero (Succ (Succ Zero)) (Succ Zero))
--   4
--   </pre>
depth :: Term -> Int

-- | 与えられた Term が含まれる、最小の集合 T を作る
--   
--   <pre>
--   &gt;&gt;&gt; minT Zero
--   fromList [TTrue,TFalse,Zero]
--   </pre>
minT :: Term -> T

module Term.HashSet

-- | <ul>
--   <li><i>定義 3.2.3 具体的な項の定義</i> 各自然数 i について、集合 Si を以下のように定義する。</li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; s 0
--   fromList []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; s 1
--   fromList [TTrue,TFalse,Zero]
--   </pre>
s :: Int -> T

-- | <ul>
--   <li><i>定義 3.3.1 項tに現れる定数の集合を Consts(t) と書き、次のように定義する</i></li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; consts TTrue
--   fromList [TTrue]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; consts (Succ (Succ (Succ Zero)))
--   fromList [Zero]
--   </pre>
consts :: Term -> T

-- | <ul>
--   <li><i>定義 3.3.2 項tのサイズを size(t) と書き、次のように定義する</i></li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; size Zero
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; size (Succ (Succ (Succ Zero)))
--   4
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; size (If Zero (Succ (Succ Zero)) (Succ Zero))
--   7
--   </pre>
size :: Term -> Int

-- | <ul>
--   <li><i>項tの深さを depth(t) と書き、次のように定義する</i></li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; depth Zero
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; depth (Succ (Succ (Succ Zero)))
--   4
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; depth (If Zero (Succ (Succ Zero)) (Succ Zero))
--   4
--   </pre>
depth :: Term -> Int

-- | 与えられた Term が含まれる、最小の集合 T を作る
--   
--   <pre>
--   &gt;&gt;&gt; minT Zero
--   fromList [TTrue,TFalse,Zero]
--   </pre>
minT :: Term -> T
